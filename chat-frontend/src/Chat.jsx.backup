import React, { useState, useEffect, useRef } from 'react';
import io from 'socket.io-client';
import { getCurrentUser, logout } from './services';
import * as api from './api';

const Chat = ({ onLogout }) => {
    const [socket, setSocket] = useState(null);
    const [messages, setMessages] = useState([]);
    const [currentMessage, setCurrentMessage] = useState('');
    const [rooms, setRooms] = useState([]);
    const [currentRoom, setCurrentRoom] = useState(null);
    const [users, setUsers] = useState([]);
    const [showUserList, setShowUserList] = useState(false);
    const [showGroupModal, setShowGroupModal] = useState(false);
    const [showManageGroupModal, setShowManageGroupModal] = useState(false);
    const [typingUsers, setTypingUsers] = useState(new Set());
    const [onlineUsers, setOnlineUsers] = useState(new Set());
    const [uploadProgress, setUploadProgress] = useState(0);
    const [isUploading, setIsUploading] = useState(false);
    const [selectedFile, setSelectedFile] = useState(null);

    const user = getCurrentUser();
    const messagesEndRef = useRef(null);
    const typingTimeoutRef = useRef(null);
    const fileInputRef = useRef(null);

    // Generate consistent color for user based on their ID
    const getUserColor = (userId) => {
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52B788',
            '#FF8C94', '#A8DADC', '#E9C46A', '#F4A261', '#E76F51'
        ];
        const hash = userId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
        return colors[hash % colors.length];
    };

    // Format date separator
    const formatDateSeparator = (date) => {
        const messageDate = new Date(date);
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        if (messageDate.toDateString() === today.toDateString()) {
            return 'Today';
        } else if (messageDate.toDateString() === yesterday.toDateString()) {
            return 'Yesterday';
        } else {
            return messageDate.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }
    };

    // Check if we need a date separator
    const shouldShowDateSeparator = (currentMsg, previousMsg) => {
        if (!previousMsg) return true;
        const currentDate = new Date(currentMsg.createdAt || currentMsg.time).toDateString();
        const previousDate = new Date(previousMsg.createdAt || previousMsg.time).toDateString();
        return currentDate !== previousDate;
    };

    // Initialize socket connection
    useEffect(() => {
        const token = localStorage.getItem('token');
        const newSocket = io(import.meta.env.VITE_API_URL || 'http://localhost:3001', {
            auth: { token }
        });

        newSocket.on('connect', () => {
            console.log('‚úÖ Connected to socket server');
            loadRooms();
            loadUsers();
        });

        newSocket.on('receive_message', (message) => {
            console.log('üì® Received message:', message);
            setMessages((prev) => {
                // Check if message already exists (prevent duplicates)
                const exists = prev.some(m =>
                    m.createdAt === message.createdAt &&
                    m.sender?._id === message.sender?._id &&
                    m.content === message.content
                );
                if (exists) {
                    console.log('‚ö†Ô∏è Duplicate message, skipping');
                    return prev;
                }
                console.log('‚úÖ Adding new message to state');
                return [...prev, message];
            });
        });

        newSocket.on('user_typing', ({ username, userId }) => {
            console.log('‚å®Ô∏è User typing:', username);
            setTypingUsers((prev) => {
                const newSet = new Set([...prev, username]);
                console.log('üìù Typing users now:', Array.from(newSet));
                return newSet;
            });
        });

        newSocket.on('user_stop_typing', ({ userId, username }) => {
            console.log('üõë User stopped typing:', username);
            setTypingUsers((prev) => {
                const newSet = new Set(prev);
                newSet.delete(username);
                console.log('üìù Typing users now:', Array.from(newSet));
                return newSet;
            });
        });

        newSocket.on('user_status_change', ({ userId, isOnline }) => {
            setOnlineUsers((prev) => {
                const newSet = new Set(prev);
                if (isOnline) {
                    newSet.add(userId);
                } else {
                    newSet.delete(userId);
                }
                return newSet;
            });
        });

        newSocket.on('user_joined_room', ({ username }) => {
            console.log(`üëã ${username} joined the room`);
        });

        newSocket.on('message_deleted', ({ messageId }) => {
            console.log('üóëÔ∏è Message deleted:', messageId);
            setMessages(prev => prev.map(msg =>
                msg._id === messageId ? { ...msg, deleted: true } : msg
            ));
        });

        newSocket.on('user_left_group', ({ roomId, username }) => {
            if (currentRoom?._id === roomId) {
                console.log(`üëã ${username} left the group`);
                // Add system message
                const systemMessage = {
                    _id: `system-${Date.now()}`,
                    content: `${username} left the group`,
                    sender: { username: 'System' },
                    createdAt: new Date().toISOString(),
                    type: 'system'
                };
                setMessages(prev => [...prev, systemMessage]);
                // Refresh room details to update member list
                loadRooms();
            }
        });

        newSocket.on('members_added', ({ roomId, addedMembers, room }) => {
            console.log('üë• Members added to group:', roomId);
            // Update rooms list
            setRooms(prev => prev.map(r => r._id === roomId ? room : r));
            // Update current room if it's the one being modified
            if (currentRoom?._id === roomId) {
                setCurrentRoom(room);
                // Add system message
                const systemMessage = {
                    _id: `system-${Date.now()}`,
                    content: `${addedMembers.length} member(s) added to the group`,
                    sender: { username: 'System' },
                    createdAt: new Date().toISOString(),
                    type: 'system'
                };
                setMessages(prev => [...prev, systemMessage]);
            }
        });

        newSocket.on('member_removed', ({ roomId, removedUserId, removedUsername, room }) => {
            console.log('üë§ Member removed from group:', removedUsername);

            // If you were removed, remove the room from your list
            if (removedUserId === user.id) {
                setRooms(prev => prev.filter(r => r._id !== roomId));
                if (currentRoom?._id === roomId) {
                    setCurrentRoom(null);
                    setMessages([]);
                }
            } else {
                // Update rooms list
                setRooms(prev => prev.map(r => r._id === roomId ? room : r));
                // Update current room if it's the one being modified
                if (currentRoom?._id === roomId) {
                    setCurrentRoom(room);
                    // Add system message
                    const systemMessage = {
                        _id: `system-${Date.now()}`,
                        content: `${removedUsername} was removed from the group`,
                        sender: { username: 'System' },
                        createdAt: new Date().toISOString(),
                        type: 'system'
                    };
                    setMessages(prev => [...prev, systemMessage]);
                }
            }
        });

        newSocket.on('connect_error', (error) => {
            console.error('‚ùå Socket connection error:', error);
        });

        newSocket.on('disconnect', (reason) => {
            console.log('üîå Socket disconnected:', reason);
        });

        setSocket(newSocket);

        return () => newSocket.close();
    }, []);

    // Load rooms
    const loadRooms = async () => {
        try {
            const [roomsData, globalRoom] = await Promise.all([
                api.getRooms(),
                api.getGlobalRoom()
            ]);

            // Filter out global room from roomsData if it exists there to avoid duplicates
            const otherRooms = roomsData.filter(r => !r.isGlobal);
            setRooms([globalRoom, ...otherRooms]);
        } catch (error) {
            console.error('Error loading rooms:', error);
        }
    };

    // Auto-select first room when socket and rooms are ready
    useEffect(() => {
        if (socket && rooms.length > 0 && !currentRoom) {
            console.log('üéØ Auto-selecting first room');
            selectRoom(rooms[0]);
        }
    }, [socket, rooms]);

    // Load users
    const loadUsers = async () => {
        try {
            const usersData = await api.getUsers();
            setUsers(usersData);
            // Initialize online users
            const online = new Set(usersData.filter(u => u.isOnline).map(u => u._id));
            setOnlineUsers(online);
        } catch (error) {
            console.error('Error loading users:', error);
        }
    };

    // Select room
    const selectRoom = async (room) => {
        console.log('üîÑ Selecting room:', room.name || room._id);

        if (currentRoom && socket) {
            console.log('üëã Leaving current room:', currentRoom._id);
            socket.emit('leave_room', currentRoom._id);
        }

        setCurrentRoom(room);
        setMessages([]);

        if (socket) {
            console.log('üö™ Joining room:', room._id);
            socket.emit('join_room', room._id);
        } else {
            console.error('‚ùå Socket not initialized when trying to join room!');
        }

        // Load message history
        try {
            const history = await api.getRoomMessages(room._id);
            console.log('üìú Loaded message history:', history.length, 'messages');
            setMessages(history);
        } catch (error) {
            console.error('Error loading messages:', error);
        }
    };

    // Create private chat
    const createPrivateChat = async (userId) => {
        try {
            const room = await api.createPrivateChat(userId);
            setRooms((prev) => {
                const exists = prev.find(r => r._id === room._id);
                if (exists) return prev;
                return [room, ...prev];
            });
            selectRoom(room);
            setShowUserList(false);
        } catch (error) {
            console.error('Error creating private chat:', error);
        }
    };

    // Create group chat
    const createGroup = async (name, memberIds) => {
        try {
            const room = await api.createGroupChat(name, memberIds);
            setRooms((prev) => [room, ...prev]);
            selectRoom(room);
            setShowGroupModal(false);
        } catch (error) {
            console.error('Error creating group:', error);
        }
    };

    // Send message
    const sendMessage = (e) => {
        e.preventDefault();
        if ((currentMessage.trim() || selectedFile) && socket && currentRoom) {
            const messageData = {
                room: currentRoom._id,
                content: currentMessage,
                type: selectedFile ? selectedFile.fileType : 'text',
                fileUrl: selectedFile?.fileUrl,
                fileName: selectedFile?.fileName,
                fileSize: selectedFile?.fileSize
            };

            socket.emit('send_message', messageData);

            setCurrentMessage('');
            setSelectedFile(null);
            stopTyping();
        }
    };

    // Handle typing
    const handleTyping = (e) => {
        setCurrentMessage(e.target.value);

        if (socket && currentRoom) {
            // Clear existing timeout
            if (typingTimeoutRef.current) {
                clearTimeout(typingTimeoutRef.current);
            }

            // Send typing start event
            socket.emit('typing_start', { room: currentRoom._id });

            // Set new timeout to stop typing after 3 seconds
            typingTimeoutRef.current = setTimeout(() => {
                console.log('‚è±Ô∏è Typing timeout - sending stop typing');
                stopTyping();
            }, 3000); // Changed from 1000ms to 3000ms
        }
    };

    const stopTyping = () => {
        if (socket && currentRoom) {
            console.log('üì§ Sending stop typing event');
            socket.emit('typing_stop', { room: currentRoom._id });
        }
    };

    // File upload
    const handleFileSelect = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        if (file.size > 50 * 1024 * 1024) {
            alert('File size must be less than 50MB');
            return;
        }

        setIsUploading(true);
        try {
            const fileData = await api.uploadFile(file, (progress) => {
                setUploadProgress(progress);
            });
            setSelectedFile(fileData);
            setCurrentMessage(`üìé ${fileData.fileName}`);
        } catch (error) {
            console.error('Error uploading file:', error);
            alert('Failed to upload file');
        } finally {
            setIsUploading(false);
            setUploadProgress(0);
        }
    };

    // Scroll to bottom
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    // Get room display name
    const getRoomName = (room) => {
        if (room.isGlobal) return 'Global Chat';
        if (room.type === 'private') {
            const otherMember = room.members.find(m => m._id !== user.id);
            return otherMember?.username || 'Private Chat';
        }
        return room.name;
    };

    // Message Actions
    const handleDeleteMessage = async (messageId) => {
        if (window.confirm('Are you sure you want to delete this message?')) {
            try {
                await api.deleteMessage(messageId);
            } catch (error) {
                console.error('Error deleting message:', error);
            }
        }
    };

    const handleCopyMessage = (content) => {
        navigator.clipboard.writeText(content);
        // Could add a toast here
    };

    // Group Management
    const handleAddMembers = async (userIds) => {
        try {
            await api.addGroupMembers(currentRoom._id, userIds);
            // Reload room to get updated members
            const updatedRooms = await api.getRooms();
            setRooms(updatedRooms);
            const updatedRoom = updatedRooms.find(r => r._id === currentRoom._id);
            if (updatedRoom) {
                setCurrentRoom(updatedRoom);
            }
            setShowManageGroupModal(false);
        } catch (error) {
            console.error('Error adding members:', error);
            alert('Failed to add members');
        }
    };

    const handleRemoveMember = async (userId) => {
        if (window.confirm('Are you sure you want to remove this member?')) {
            try {
                await api.removeGroupMember(currentRoom._id, userId);
                // Reload room to get updated members
                const updatedRooms = await api.getRooms();
                setRooms(updatedRooms);
                const updatedRoom = updatedRooms.find(r => r._id === currentRoom._id);
                if (updatedRoom) {
                    setCurrentRoom(updatedRoom);
                }
            } catch (error) {
                console.error('Error removing member:', error);
                alert('Failed to remove member');
            }
        }
    };


    const handleLeaveGroup = async () => {
        if (!currentRoom || currentRoom.type !== 'group') return;
        if (window.confirm('Are you sure you want to leave this group?')) {
            try {
                await api.leaveGroup(currentRoom._id);
                setCurrentRoom(null);
                loadRooms();
            } catch (error) {
                console.error('Error leaving group:', error);
            }
        }
    };

    // Format timestamp
    const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
    };

    return (
        <div className="chat-container">
            {/* Sidebar */}
            <div className="sidebar">
                <div className="sidebar-header">
                    <h3>Arangam</h3>
                    <div className="header-actions">
                        <button onClick={() => setShowUserList(true)} className="btn-icon" title="New Chat">
                            üí¨
                        </button>
                        <button onClick={() => setShowGroupModal(true)} className="btn-icon" title="New Group">
                            üë•
                        </button>
                        <button onClick={onLogout} className="btn-small">Logout</button>
                    </div>
                </div>

                <div className="rooms-list">
                    {rooms.map((room) => (
                        <div
                            key={room._id}
                            className={`room-item ${currentRoom?._id === room._id ? 'active' : ''}`}
                            onClick={() => selectRoom(room)}
                        >
                            <div className="room-avatar">
                                {room.isGlobal ? 'üåê' : room.type === 'group' ? 'üë•' : 'üë§'}
                            </div>
                            <div className="room-info">
                                <div className="room-name">{getRoomName(room)}</div>
                                {room.lastMessage && (
                                    <div className="room-last-message">
                                        {room.lastMessage.content?.substring(0, 30)}...
                                    </div>
                                )}
                            </div>
                            {room.type === 'private' && room.members.find(m => m._id !== user.id && onlineUsers.has(m._id)) && (
                                <div className="online-indicator"></div>
                            )}
                        </div>
                    ))}
                </div>
            </div>

            {/* Chat Area */}
            <div className="chat-area">
                {currentRoom ? (
                    <>
                        <div className="chat-header">
                            <div className="header-info">
                                <h3>{getRoomName(currentRoom)}</h3>
                                {currentRoom.type === 'private' && (
                                    <span className="status-text">
                                        {currentRoom.members.find(m => m._id !== user.id && onlineUsers.has(m._id)) ? 'Online' : 'Offline'}
                                    </span>
                                )}
                            </div>
                            {currentRoom.type === 'group' && (
                                <div className="header-actions">
                                    {(currentRoom.creator?._id === user.id || currentRoom.creator === user.id) ? (
                                        <button className="btn-small" onClick={() => setShowManageGroupModal(true)}>Manage</button>
                                    ) : (
                                        <button className="btn-small danger" onClick={handleLeaveGroup}>Leave</button>
            onChange={handleFileSelect}
                                    style={{ display: 'none' }}
        />
                                    <button
                                        type="button"
                                        onClick={() => fileInputRef.current?.click()}
                                        className="btn-icon"
                                        disabled={isUploading}
                                    >
                                        üìé
                                    </button>
                                    <input
                                        type="text"
                                        value={currentMessage}
                                        onChange={handleTyping}
                                        placeholder={isUploading ? `Uploading... ${uploadProgress}%` : "Type a message..."}
                                        disabled={isUploading}
                                    />
                                    <button type="submit" disabled={isUploading}>Send</button>
                                </form>
                    </>
                        ) : (
                        <div className="no-room-selected">
                            <h2>Welcome to Arangam</h2>
                            <p>Select a chat or start a new conversation</p>
                        </div>
)}
                    </div >

                {/* User List Modal */}
                {
                    showUserList && (
                        <div className="modal-overlay" onClick={() => setShowUserList(false)}>
                            <div className="modal" onClick={(e) => e.stopPropagation()}>
                                <div className="modal-header">
                                    <h3>Start New Chat</h3>
                                    <button onClick={() => setShowUserList(false)} className="btn-close">√ó</button>
                                </div>
                                <div className="modal-body">
                                    {users.map((u) => (
                                        <div
                                            key={u._id}
                                            className="user-item"
                                            onClick={() => createPrivateChat(u._id)}
                                        >
                                            <div className="user-avatar">üë§</div>
                                            <div className="user-info">
                                                <div className="user-name">{u.username}</div>
                                                <div className="user-email">{u.email}</div>
                                            </div>
                                            {onlineUsers.has(u._id) && <div className="online-indicator"></div>}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )
                }

                {/* Group Modal */}
                {
                    showGroupModal && (
                        <GroupModal
                            users={users}
                            onClose={() => setShowGroupModal(false)}
                            onCreate={createGroup}
                        />
                    )
                }

                {/* Manage Group Modal */}
                {
                    showManageGroupModal && currentRoom && (
                        <ManageGroupModal
                            room={currentRoom}
                            users={users}
                            currentUserId={user.id}
                            onClose={() => setShowManageGroupModal(false)}
                            onAddMembers={handleAddMembers}
                            onRemoveMember={handleRemoveMember}
                        />
                    )
                }
            </div >
            );
};

            // Group Modal Component
            const GroupModal = ({users, onClose, onCreate}) => {
    const [groupName, setGroupName] = useState('');
            const [selectedMembers, setSelectedMembers] = useState([]);

    const toggleMember = (userId) => {
                setSelectedMembers((prev) =>
                    prev.includes(userId)
                        ? prev.filter((id) => id !== userId)
                        : [...prev, userId]
                );
    };

    const handleCreate = () => {
        if (groupName.trim() && selectedMembers.length > 0) {
                onCreate(groupName, selectedMembers);
        }
    };

            return (
            <div className="modal-overlay" onClick={onClose}>
                <div className="modal" onClick={(e) => e.stopPropagation()}>
                    <div className="modal-header">
                        <h3>Create Group</h3>
                        <button onClick={onClose} className="btn-close">√ó</button>
                    </div>
                    <div className="modal-body">
                        <div className="form-group">
                            <label>Group Name</label>
                            <input
                                type="text"
                                value={groupName}
                                onChange={(e) => setGroupName(e.target.value)}
                                placeholder="Enter group name"
                            />
                        </div>
                        <div className="form-group">
                            <label>Select Members ({selectedMembers.length})</label>
                            <div className="members-list">
                                {users.map((u) => (
                                    <div key={u._id} className="member-item">
                                        <input
                                            type="checkbox"
                                            checked={selectedMembers.includes(u._id)}
                                            onChange={() => toggleMember(u._id)}
                                        />
                                        <span>{u.username}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <button
                            onClick={handleCreate}
                            className="btn-primary"
                            disabled={!groupName.trim() || selectedMembers.length === 0}
                        >
                            Create Group
                        </button>
                    </div>
                </div>
            </div>
            );
};

            // Manage Group Modal Component
            const ManageGroupModal = ({room, users, currentUserId, onClose, onAddMembers, onRemoveMember}) => {
    const [selectedUsers, setSelectedUsers] = useState([]);
            const [activeTab, setActiveTab] = useState('members'); // 'members' or 'add'

    // Filter out users who are already members
    const availableUsers = users.filter(u =>
        !room.members.some(m => m._id === u._id) && u._id !== currentUserId
            );

    const toggleUser = (userId) => {
                setSelectedUsers(prev =>
                    prev.includes(userId)
                        ? prev.filter(id => id !== userId)
                        : [...prev, userId]
                );
    };

    const handleAddMembers = () => {
        if (selectedUsers.length > 0) {
                onAddMembers(selectedUsers);
            setSelectedUsers([]);
        }
    };

            return (
            <div className="modal-overlay" onClick={onClose}>
                <div className="modal" onClick={(e) => e.stopPropagation()}>
                    <div className="modal-header">
                        <h3>Manage Group: {room.name}</h3>
                        <button className="btn-close" onClick={onClose}>√ó</button>
                    </div>

                    {/* Tabs */}
                    <div className="modal-tabs">
                        <button
                            className={`tab-button ${activeTab === 'members' ? 'active' : ''}`}
                            onClick={() => setActiveTab('members')}
                        >
                            Members ({room.members.length})
                        </button>
                        <button
                            className={`tab-button ${activeTab === 'add' ? 'active' : ''}`}
                            onClick={() => setActiveTab('add')}
                        >
                            Add Members
                        </button>
                    </div>

                    <div className="modal-body">
                        {activeTab === 'members' ? (
                            <div className="members-list">
                                {room.members.map(member => (
                                    <div key={member._id} className="member-item">
                                        <div className="user-avatar">üë§</div>
                                        <div className="user-info">
                                            <div className="user-name">
                                                {member.username}
                                                {(member._id === room.creator?._id || member._id === room.creator) && <span className="badge">Creator</span>}
                                                {member._id === currentUserId && <span className="badge">You</span>}
                                            </div>
                                            <div className="user-email">{member.email}</div>
                                        </div>
                                        {member._id !== room.creator?._id && member._id !== room.creator && member._id !== currentUserId && (
                                            <button
                                                className="btn-small danger"
                                                onClick={() => onRemoveMember(member._id)}
                                            >
                                                Remove
                                            </button>
                                        )}
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <>
                                <div className="members-list">
                                    {availableUsers.length === 0 ? (
                                        <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>
                                            No users available to add
                                        </p>
                                    ) : (
                                        availableUsers.map(u => (
                                            <div key={u._id} className="member-item">
                                                <input
                                                    type="checkbox"
                                                    checked={selectedUsers.includes(u._id)}
                                                    onChange={() => toggleUser(u._id)}
                                                />
                                                <div className="user-avatar">üë§</div>
                                                <div className="user-info">
                                                    <div className="user-name">{u.username}</div>
                                                    <div className="user-email">{u.email}</div>
                                                </div>
                                            </div>
                                        ))
                                    )}
                                </div>
                                {availableUsers.length > 0 && (
                                    <button
                                        onClick={handleAddMembers}
                                        className="btn-primary"
                                        disabled={selectedUsers.length === 0}
                                    >
                                        Add {selectedUsers.length > 0 ? `(${selectedUsers.length})` : ''} Members
                                    </button>
                                )}
                            </>
                        )}
                    </div>
                </div>
            </div>
            );
};

            export default Chat;
